\documentclass{bmstu}

\usepackage{biblatex}
\usepackage{array}
\usepackage{amsmath}

\addbibresource{inc/biblio/sources.bib}

\begin{document}

\makecourseworktitle
    {Информатика и системы управления}
    {Программное обеспечение ЭВМ и информационные технологии}
    {Разработка базы данных для хранения и обработки данных магазина одежды}
    {ИУ7-63Б}
    {И.~А.~Гринкевич}
    {А.~Л.~Исаев}
    {}
    {}
    
\setcounter{page}{3}

{\centering \chapter*{РЕФЕРАТ}}

Расчетно-пояснительная записка 53 с., 12 рис., 9 табл., 18 источн., 1 прил.

\noindent АВИАБИЛЕТЫ, АВИАПЕРЕЛЕТЫ, БАЗЫ ДАННЫХ, ВЕБ-ПРИЛОЖЕНИЕ, РЕЛЯЦИОННАЯ МОДЕЛЬ ДАННЫХ, SQL

Объектом разработки является база данных и приложение к ней.

Объектом исследования являются кластеризованные и некластеризованные индексы.

Цель работы: разработка базы данных для хранения и обработки данных авиакомпании и веб-приложения, которое будет ее использовать.

В результате выполнения работы была разработана база данных для хранения и обработки данных авиакомпании и веб-приложение, использующее эту базу данных.

В ходе выполнения конструкторской части были выделены шесть сущностей: пользователь, заказ, рейс, билет, самолет и услуга. 
А также три роли на уровне базы данных: клиент, модератор и администратор.

При выполнении технологической части были выбраны средства реализации программного обеспечения (язык программирования C\texttt{\#} и система управления базами данных Microsoft SQL Server), реализован интерфейс доступа к базе данных и проведено тестирование разработанного функционала (mock-тесты, интеграционные тесты и тесты по сценариям использования).

В ходе проведения исследования было установлено, что при 250 тысячах строк в таблице использование и кластеризованного, и некластеризованного индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней на примере одной из таблиц спроектированной базы данных.

Область применения результатов --- дальнейшее развитие и расширение приложения для поиска и покупки билетов на любые виды транспорта.

{\centering \maketableofcontents}

{\centering \chapter*{ПЕРЕЧЕНЬ СОКРАЩЕНИЙ И ОБОЗНАЧЕНИЙ}}

В настоящей расчетно-пояснительной записке к курсовой работе применяют следующие сокращения и обозначения:

\begin{table}[H]
\begin{tabular}{p{5cm}p{10.5cm}}
БД & База данных
\tabularnewline
ПО & Программное обеспечение
\tabularnewline
СУБД & Система управления базами данных
\tabularnewline
ER-диаграмма & Диаграмма <<сущность-связь>> (от англ. entity-relationship)
\tabularnewline
GPS & Система глобального позиционирования (Global Positioning System)
\tabularnewline
ID & Идентификатор
\tabularnewline
MPA & Многостраничное приложение (Multi Page Application)
\tabularnewline
SPA & Одностраничное приложение (Single Page Application)
\tabularnewline
Use case диаграмма & Диаграмма вариантов использования
\tabularnewline
\end{tabular}
\end{table}

{\centering \chapter*{ВВЕДЕНИЕ}}
\addcontentsline{toc}{chapter}{ВВЕДЕНИЕ}

В современном мире информация является ключевым ресурсом для успешного ведения бизнеса. Эффективное управление данными становится все более важным для компаний, особенно в сфере розничной торговли. Магазины одежды не являются исключением, их успешная деятельность напрямую зависит от умения эффективно хранить, управлять разнообразными данными, связанными с продажами, ассортиментом, клиентами и многими другими аспектами бизнеса.

Целью данной курсовой работы является разработка базы данных для хранения и обработки данных магазина одежды.

Для достижения поставленной цели необходимо решить следующие задачи:
\begin{enumerate}
\item[1)] проанализировать предметную область;
\item[2)] сформулировать требования и ограничения к разрабатываемой базе данных;
\item[3)] формализовать информацию, хранимую в БД;
\item[4)] разработать структуру базы данных и определить ролевую модель в контексте БД;
\item[5)] избрать инструменты для разработки и реализовать спроектированную базу данных.;
\item[6)] исследовать характеристики разработанного программного обеспечения.
\end{enumerate}

\chapter{Аналитическая часть}

\section{Анализ предметной области}

В настоящее время магазины одежды играют важную роль в розничной торговле России. Они предоставляют широкий ассортимент товаров и являются основными местами для покупки одежды и аксессуаров для населения. Среди наиболее популярных онлайн-магазинов одежды в России следует выделить такие платформы, как stockmann.ru и lamoda.ru. Они зарекомендовали себя как надежные и удобные ресурсы для поиска и приобретения модной одежды и обуви.

Однако, несмотря на популярность и широкий выбор товаров, часто пользователи сталкиваются с проблемами в использовании этих онлайн-платформ. Один из основных аспектов, на который обращают внимание, является перегруженный интерфейс и сложность использования. Слишком много информации, разнообразные дополнительные функции и не всегда интуитивно понятный дизайн могут создавать неудобства для покупателей. По этой причине одной из задач курсовой работы заключается в разработке базы данных, которая позволит магазину одежды предоставить простой и понятный функционал для своих клиентов.

Разработка простого и понятного функционала для магазина одежды позволит повысить удовлетворенность клиентов и укрепить позиции магазина на рынке.

\section{Требования к базе данных и приложению}

Приложение должно предоставлять пользователям возможность искать товары по следующим параметрам:
\begin{enumerate}
	\item[1)] пол человека;
	\item[2)] категория;
	\item[3)] бренд.
\end{enumerate}

Также должна быть возможность сортировки товаров по возрастанию или убыванию цены.

Пользователи должны иметь возможность зарегистрироваться, авторизоваться, просмотреть информацию о товарах и брендах, добавить и удалить товары из корзины, совершить заказ, просмотреть историю заказов.

Администратор должен иметь возможность просматривать информацию о заказах пользователей, изменять информацию о пользователях, заказах, товарах и брендах, а также загружать и удалять новые товары и бренды.

\section{Модели баз данных}

\subsection{Дореляционные базы данных}

Дореляционные базы данных - это тип баз данных, который не использует традиционные таблицы и связи, характерные для реляционных баз данных. Вместо этого они организуют данные в более гибких структурах, таких как документы, графы или временные ряды. Это позволяет более эффективно хранить и обрабатывать данные с учетом их специфики. Примерами дореляционных баз данных могут служить NoSQL базы данных, такие как MongoDB, CouchDB, Cassandra.

Преимущества дореляционных баз данных включают более гибкую структуру данных, что делает их подходящими для работы с неструктурированными или полуструктурированными данными. Они также могут быть более масштабируемыми в определенных сценариях, таких как обработка больших объемов данных.

Однако дореляционные базы данных могут потребовать более сложных запросов и могут не обеспечивать те же уровни нормализации данных, что и реляционные базы данных.

\subsection{Реляционные базы данных}

Реляционные базы данных - это тип баз данных, который использует табличную структуру для хранения данных и устанавливает связи между этими таблицами. Каждая таблица представляет собой набор записей с атрибутами, а связи между таблицами обеспечивают возможность объединения данных из разных таблиц при выполнении запросов.

Преимущества реляционных баз данных включают структурированный подход к хранению данных, что обеспечивает эффективность при работе с нормализованными данными. Они также обладают мощным языком запросов SQL, который позволяет легко извлекать и модифицировать данные.

Однако реляционные базы данных могут столкнуться с проблемами при работе с неструктурированными данными или данными, требующими гибких схем.

\subsection{Постреляционные базы данных}

Постреляционные базы данных - это новый подход к хранению данных, который пытается объединить преимущества как дореляционных, так и реляционных баз данных. Они предлагают гибкую схему данных, что делает их более способными к работе с разнообразными данными. Постреляционные базы данных также предлагают улучшенные механизмы обработки больших объемов данных.

Примеры постреляционных баз данных включают ArangoDB, Amazon DynamoDB и другие. Эти системы стремятся объединить гибкость дореляционных баз данных с мощью реляционных систем.

\section{Информация, подлежащая хранению в базе данных}

В базе данных нужно будет хранить информацию о пяти сущностях: пользователь, бренд, товар, заказ и позиция заказа.
\begin{enumerate}
\item Пользователь. 
Информация о зарегистрированных пользователях: логин, пароль, имя, пол, роль.
\item Бренд. 
Информация о брендах товаров: название, год основания, идентификатор логотипа, название компании владельца.
\item Товар. 
Информация о товаре: категория, цена, пол, идентификатор изображения, бренд, наличие.
\item Заказ.
Информация о заказе: дата совершения, заказчик, цена, статус.
\item Позиция заказа.
Информация о позиции в заказе: заказ, товар, количество.
\end{enumerate}

Идентификаторы логотипа бренда и изображения товара представляют собой ID на сторонних сервисах для хранения изображений.

Так как база данных не имеет большого количества связей и хранимые в ней данные структурированы, для достижения поставленной цели была выбрана реляционная модель баз данных.

\pagebreak
\section{ER-диаграмма сущностей базы данных}

На рисунке~\ref{img:er} показана диаграмма <<сущность-связь>> проектируемой базы данных в нотации Чена. 
Представлены пять сущностей и их свойства.

\includeimage
    {er}
    {f}
    {H}
    {1\textwidth}
    {ER-диаграмма}
    
\section{Пользователи приложения}

Пользователи могут иметь одну из трех ролей: посетитель, клиент и администратор.

Посетитель --- неавторизованный пользователь. 
Он может смотреть товары и бренды, авторизоваться и зарегистрироваться. На рисунке \ref{img:use-case-01} представлена use-case диаграмма для роли посетитель.

\includeimage
{use-case-01}
{f}
{H}
{.4\textwidth}
{Use-case диаграмма для роли посетитель}

Клиент --- зарегистрированный и авторизованный пользователь. 
Он имеет те же возможности что и посетитель (кроме регистрации), но в добавок он может добавить или удалить товары из корзины, совершить заказ, просмотреть историю заказов. На рисунке \ref{img:use-case-02} представлена use-case диаграмма для роли клиент.

\includeimage
{use-case-02}
{f}
{H}
{.4\textwidth}
{Use-case диаграмма для роли клиент}

Администратор имеет те же возможности что и клиент, но вдобавок может просматривать информацию о заказах пользователей, изменять информацию о пользователях, заказах, товарах и брендах, а также загружать и удалять новые товары и бренды. На рисунке \ref{img:use-case-03} представлена use-case диаграмма для роли администратор.

\includeimage
{use-case-03}
{f}
{H}
{.4\textwidth}
{Use-case диаграмма для роли администратор}

\section*{Вывод из аналитической части}

По ходу выполнения аналитической части данной курсовой работы была проанализирована рассматриваемая предметная область, а так же сформулированы требования и ограничения к разрабатываемой БД. Были рассмотрены модели баз данных и выбрана подходящая под поставленные задачи. Также была формализована информация, хранящиеся в БД и представлены диаграммы сущностей разрабатываемой базы данных и вариантов использования пользователями.

\chapter{Конструкторская часть}

\section{Описание сущностей базы данных}

В аналитической части были выделены шесть сущностей базы данных: пользователь, рейс, билет, самолет, услуга и заказ. 
На рисунке~\ref{img:db-diagram} представлена диаграмма базы данных.

\includeimage
    {db-diagram}
    {f}
    {H}
    {.9\textwidth}
    {Диаграмма базы данных}

В таблицах~\ref{tabular:users}--\ref{tabular:services} описаны атрибуты таблиц базы данных.

\begin{table}[H]
\caption{Атрибуты таблицы <<Пользователи>>}
\label{tabular:users}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Role & строка & Роль пользователя
\tabularnewline
\hline
Email & строка & Адрес электронной почты
\tabularnewline
\hline
Password & строка & Зашифрованный пароль
\tabularnewline
\hline
FirstName & строка & Имя пользователя
\tabularnewline
\hline
LastName & строка & Фамилия пользователя
\tabularnewline
\hline
RegDate & дата и время & Дата и время регистрации
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Заказы>>}
\label{tabular:orders}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
UserId & целое & Идентификатор пользователя --- внешний ключ
\tabularnewline
\hline
Status & строка & Статус заказа
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы-связки <<Билеты-Услуги>>}
\label{tabular:tickets_services}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
TicketId & целое & Идентификатор билета --- первичный и внешний ключ
\tabularnewline
\hline
ServiceId & целое & Идентификатор услуги --- первичный и внешний ключ
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Билеты>>}
\label{tabular:tickets}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
FlightId & целое & Идентификатор рейса --- внешний ключ
\tabularnewline
\hline
OrderId & целое & Идентификатор заказа
\tabularnewline
\hline
Row & целое & Ряд в самолете
\tabularnewline
\hline
Place & символ & Место в ряду
\tabularnewline
\hline
Class & строка & Класс билета
\tabularnewline
\hline
Refund & логический тип & Возможен ли возврат билета
\tabularnewline
\hline
Price & денежный тип & Стоимость
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Рейсы>>}
\label{tabular:flights}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
PlaneId & целое & Идентификатор самолета --- внешний ключ
\tabularnewline
\hline
DeparturePoint & строка & Пункт вылета
\tabularnewline
\hline
ArrivalPoint & строка & Пункт прибытия
\tabularnewline
\hline
DepartureDateTime & дата и время & Дата и время вылета
\tabularnewline
\hline
ArrivalDateTime & дата и время & Дата и время прибытия
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Самолеты>>}
\label{tabular:planes}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Manufacturer & строка & Название компании-производителя
\tabularnewline
\hline
Model & строка & Название модели самолета
\tabularnewline
\hline
EconomyClassNum & целое & Количество мест экономкласса
\tabularnewline
\hline
BusinessClassNum & целое & Количество мест бизнес-класса
\tabularnewline
\hline
FirstClassNum & целое & Количество мест первого класса
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Атрибуты таблицы <<Услуги>>}
\label{tabular:services}
\begin{tabular}{|>{\raggedleft}p{4cm}|>{\raggedleft}p{3cm}|>{\raggedleft}p{8cm}|}
\hline
\textbf{Имя атрибута} & \textbf{Тип атрибута} & \textbf{Описание}
\tabularnewline
\hline
Id & целое & Идентификатор --- первичный ключ
\tabularnewline
\hline
Name & строка & Название услуги
\tabularnewline
\hline
Price & денежный тип & Стоимость услуги
\tabularnewline
\hline
EconomyClass & логический тип & Доступна ли услуга для билета экономкласса
\tabularnewline
\hline
BusinessClass & логический тип & Доступна ли услуга для билета бизнес-класса
\tabularnewline
\hline
FirstClass & логический тип & Доступна ли услуга для билета первого класса
\tabularnewline
\hline
\end{tabular}
\end{table}

\section{Описание ограничений целостности базы данных}

На данные, хранящиеся в базе, должны быть наложены определенные ограничения для обеспечения ее целостности.

Ограничения для таблицы <<Пользователи>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Роль пользователя не может отсутствовать.
Адрес электронной почты не может отсутствовать и должен быть уникальным. 
Пароль не может отсутствовать. 
Дата регистрации пользователя не должна отсутствовать.

Ограничения для таблицы <<Заказы>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор пользователя --- положительное число, внешний ключ, не должен отсутствовать. 
Статус не должен отсутствовать.

Ограничения для таблицы <<Рейсы>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор самолета --- положительное число, внешний ключ, не должен отсутствовать. 
Пункты вылета и прибытия не должны отсутствовать. 
Дата и время вылета и прибытия не должны отсутствовать, притом дата и время вылета должны быть меньше даты и времени прибытия. 

Ограничения для таблицы <<Билеты>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Идентификатор рейса --- положительное число, внешний ключ, не должен отсутствовать. 
Ряд в самолете --- положительное число, не должен отсутствовать. 
Место в ряду не должно отсутствовать. 
Класс не должен отсутствовать. 
Возможность возврата не должна отсутствовать. 
Стоимость --- положительное число, не должна отсутствовать.

Ограничения для таблицы <<Самолеты>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Производитель и модель не должны отсутствовать. 
Количество мест разных классов --- неотрицательные числа, не должны отсутствовать. 

Ограничения для таблицы <<Услуги>>. 
Идентификатор --- уникальное положительное число, первичный ключ. 
Наименование услуги не должно отсутствовать. 
Стоимость --- положительное число, не должна отсутствовать.
Доступность для мест разных классов не должна отсутствовать.

Ограничения для таблицы-связки <<Билеты-Услуги>>. 
Идентификатор билета --- положительное число, первичный и внешний ключ. 
Идентификатор услуги --- положительное число, первичный и внешний ключ. 

\pagebreak
\section{Описание проектируемой функции на уровне базы данных}

Пользователь приложения может заказывать билеты и услуги. 
Так как они находятся в разных таблицах, нужно выполнять два запроса для того, чтобы посчитать стоимость всех билетов и услуг, заказанных пользователем. 
Для этой цели удобно реализовать функцию, которая по идентификатору заказа будет возвращать его стоимость. 
На рисунке~\ref{img:function} представлена схема проектируемой функции.

\includeimage
    {function}
    {f}
    {H}
    {0.6\textwidth}
    {Функция, возвращающая стоимость заказа}

В функции используются следующие переменные:

\begin{enumerate}
\item[1)] orderId --- идентификатор заказа (входной параметр);
\item[2)] result --- стоимость заказа (выходной параметр);
\item[3)] sumTickets --- стоимость билетов, входящих в заказ;
\item[4)] sumServices --- стоимость услуг для билетов, входящих в заказ.
\end{enumerate}

\section{Описание ролевой модели на уровне базы данных}

В аналитической части было указано, что в приложении есть четыре типа пользователей: посетители, клиенты, модераторы и администраторы. 
Взаимодействией пользователей с базой данных должно происходить не напрямую, а с помощью определенного промежуточного слоя. 
Таким образом, для посетителя можно вообще не создавать роль на уровне базы данных. 
При попытке зазать билет, пользователь будет переадресован на страницу регистрации. 
Для трех других типов пользователей нужно создавать роли.

Доступны три роли на уровне базы данных.
\begin{enumerate}
\item Клиент взаимодействует с базой данных через приложение и получает информацию о рейсах, билетах, самолетах, услугах и своих заказах. 
Также клиент может изменить информацию о себе, которая хранится в таблице <<Пользователи>>.
\item Модератор обладает всеми правами клиента. 
Он тоже взаимодействует с базой данных через приложение и может добавлять информацию о билетах и рейсах или удалять ее. 
\item Администратор обладает всеми правами модератора. 
Он взаимодействует с базой данных и через приложение, и напрямую. 
Администратор может добавлять, удалять или изменять любую информацию, которая хранится в базе данных.
\end{enumerate}

\section*{Вывод из конструкторской части}

В ходе выполнения конструкторской части куросовой работы была создана диграмма базы данных; описаны сущности базы данных; описаны проектируемые ограничения целостности базы данных; описана функция на уровне базы данных, которая считает стоимость заказа, в виде схемы алгоритма и описана проектируемая ролевая модель на уровне базы данных, которая состоит из трех ролей --- клиент, модератор и администратор.

\chapter{Технологическая часть}

\section{Средства реализации}

Веб-приложения бывают одностраничными (SPA) и многостраничными (MPA). 
Оба подхода используются для разных целей и имеют свои преимущества и недостатки.

Одностраничные приложения обладают следующими преимуществами:

\begin{enumerate}
\item[1)] SPA загружают необходимые компоненты только один раз, а последующие обновления страницы выполняются динамически, не требуя полной перезагрузки страницы, что приводит к ускорению загрузки страниц и более плавному взаимодействию с пользователем;
\item[2)] SPA легче поддерживать, поскольку они используют модульную конструкцию, где каждый компонент отвечает за свою функциональность, что упрощает изменение или замену компонентов, не затрагивая другие части приложения;
\item[3)] запросы к серверу сведены к минимуму, поскольку приложение использует программный интерфейс (API) для извлечения данных с сервера, а не требует, чтобы сервер создавал целую страницу для каждого запроса;
\item[4)] когда пользователь находится в автономном режиме, SPA может отображать кэшированную версию веб-приложения, чтобы пользователь мог продолжать использовать приложение даже при отсутствии подключения к Интернету;
\item[5)] клиентская и серверная части приложения разделены, что позволяет разработчикам изменять одно, не затрагивая другое~\cite{Davidson2023}.
\end{enumerate}

Несмотря на свои преимущества, одностраничные приложения имеют несколько существенных недостатков:

\begin{enumerate}
\item[1)] поскольку SPA загружают весь свой контент одновременно, первоначальная загрузка может занять больше времени, что может быть проблемой для пользователей с медленным подключением к Интернету или старых устройств;
\item[2)] SPA трудно оптимизировать для поисковых систем, потому что они обычно имеют только один URL-адрес и ограниченный контент при начальной загрузке страницы, что влияет на их рейтинг в поисковых системах;
\item[3)] SPA могут быть несовместимы со старыми браузерами или устройствами, что может ограничить потенциальную базу пользователей;
\item[4)] поскольку большая часть логики приложения выполняется на стороне клиента, оно может быть более уязвимо для определенных типов атак, таких как межсайтовый скриптинг или подделка межсайтовых запросов~\cite{Davidson2023}.
\end{enumerate}

Преимущества многостраничных приложений:

\begin{enumerate}
\item[1)] MPA, как правило, хорошо ранжируются в результатах поисковых систем, поскольку каждая страница имеет уникальный URL-адрес и может быть проиндексирована отдельно, что означает, что каждая страница в MPA может занимать независимое место в результатах поиска, потенциально увеличивая трафик на сайт;
\item[2)] поскольку MPA отправляют отдельные запросы для каждой страницы, проще реализовать меры безопасности, такие как аутентификация и авторизация;
\item[3)] в то время как SPA обеспечивают более высокую производительность после загрузки начальной страницы, начальное время загрузки MPA часто быстрее, поскольку браузеру нужно загрузить только содержимое текущей страницы, а не все содержимое всего приложения;
\item[4)] MPA --- это классический способ создания веб-страниц, поэтому он совместим с большинством старых браузеров и устаревших систем~\cite{Davidson2023}.
\end{enumerate}

Основные недостатки многостраничных приложений:

\begin{enumerate}
\item[1)] поскольку MPA требуют полной перезагрузки страницы, когда пользователь взаимодействует с приложением, они обеспечивают низкую производительность, что негативно влияет на взаимодействие с пользователем;
\item[2)] MPA требуют более сложной логики на стороне сервера по сравнению с SPA, поскольку каждая страница должна проектироваться и разрабатываться отдельно, что может привести к необходимости поддерживать больше кода и повысить риск возникновения ошибок;
\item[3)] MPA требуют, чтобы сервер обрабатывал больше запросов, поскольку для загрузки каждой страницы требуется отдельный запрос, что может привести к увеличению нагрузки на сервер и увеличению времени отклика, особенно для приложений с большим количеством пользователей~\cite{Davidson2023}.
\end{enumerate}

Многостраничные приложения обычно выбираются для создания веб-сайтов с большим количеством контента, такие как новостные сайты или сайты электронной коммерции, где каждая страница представляет собой отдельный фрагмент контента или продукта~\cite{Davidson2023}\cite{Tran2022}. 
Так как цель курсовой работы --- реализация приложения для поиска авиабилетов, был выбран подход с созданием многостраничных приложений.

Для реализации программного обеспечения был выбран язык программирования C\texttt{\#} ввиду следующих причин:

\begin{enumerate}
\item[1)] на языке программирования C\texttt{\#} можно создавать многостраничные веб-приложения с помощью кроссплатформенного фреймворка ASP.NET Core;
\item[2)] фреймворк ASP.NET Identity представляет встроенную систему аутентификации и авторизации;
\item[3)] в стандартной библиотеке C\texttt{\#} реализованы необходимые структуры данных для работы с БД (такие как IEnumerable<T>, List<T> и SortedSet<T>);
\item[4)] ASP.NET MVC Framework реализует шаблон Model-View-Controller, который предназначен для отделения бизнес-логики приложения от визуализации данных, что позволяет проводить тестирование одних компонентов приложения независимо от других.
\end{enumerate}

Помимо языка программирования нужно выбрать систему управления базами данных. 
Наиболее популярные реляционные системы управления базами данных: Oracle, MySQL, Microsoft SQL Server, PostgreSQL и SQLite~\cite{Statistics1}\cite{Statistics2}.

Для реализации программного продукта была выбрана СУБД Microsoft SQL Server ввиду следующих причин:

\begin{enumerate}
\item[1)] она подходит для многопользовательских приложений;
\item[2)] может работать без использования контейнеризации;
\item[3)] язык программирования C\texttt{\#} предоставляет необходимый набор инструментов для работы с этой СУБД.
\end{enumerate}

Таким образом, с помощью языка C\texttt{\#} и СУБД Microsoft SQL Server можно реализовать программное обеспечение, которое соответствует перечисленным в аналитическом разделе требованиям.

\section{Реализация сущностей базы данных}

В листингах~\ref{lst:user.cs}--\ref{lst:service.cs} показана реализация сущностей базы данных.

\includelisting
{user.cs}{Cущность <<Пользователь>>}

\pagebreak
\includelisting
{flight.cs}{Cущность <<Рейс>>}

\includelisting
{order.cs}{Cущность <<Заказ>>}

\includelisting
{ticket.cs}{Cущность <<Билет>>}

\pagebreak
\includelisting
{plane.cs}{Cущность <<Самолет>>}

\includelisting
{service.cs}{Cущность <<Услуга>>}


\section{Реализация ограничений целостности базы данных}

В листингах~\ref{lst:constraints_users.sql}--\ref{lst:constraints_tickets_services.sql} показана реализация ограничений целостности базы данных (ограничения задаются при создании таблиц).

\includelisting
{constraints_users.sql}{Ограничения для таблицы <<Пользователи>>}

\includelisting
{constraints_orders.sql}{Ограничения для таблицы <<Заказы>>}

\includelisting
{constraints_flights.sql}{Ограничения для таблицы <<Рейсы>>}

\includelisting
{constraints_planes.sql}{Ограничения для таблицы <<Самолеты>>}

\includelisting
{constraints_services.sql}{Ограничения для таблицы <<Услуги>>}

\includelisting
{constraints_tickets.sql}{Ограничения для таблицы <<Билеты>>}

\includelisting
{constraints_tickets_services.sql}{Ограничения для вспомогательной таблицы-связки <<Билеты-Услуги>>}

\pagebreak
\section{Реализация функции на уровне базы данных}

В листинге~\ref{lst:db_function.sql} показана реализация функции на уровне базы данных, которая по идентификатору заказа считает стоимость всех билетов и услуг. 
Здесь используется функция COALESCE из Transact-SQL, которая вычисляет аргументы по порядку и возвращает текущее значение первого выражения, изначально не вычисленного как \mbox{NULL~\cite{Coalesce}}.

\includelisting
{db_function.sql}{Функция, возвращающая стоимость всех билетов и услуг конкретного заказа}

\pagebreak
\section{Реализация ролевой модели на уровне базы данных}

В листинге~\ref{lst:db_roles.sql} показана реализация ролевой модели на уровне базы данных, которая состоит из трех ролей: клиента (db\_customer), модератора (db\_moderator) и администратора (db\_admin).

\includelisting
{db_roles.sql}{Ролевая модель на уровне базы данных}

\section{Реализация интерфейса доступа к базе данных}

Для обеспечения взаимодействия приложения с базой данных были написаны интерфейсы, которые предоставляют моделям (сущностям) определенные методы для работы с данными. 
У каждой модели есть приватное поле, которое представляет собой экземпляр конкретного интерфейса.

В листингах~\ref{lst:irepository.cs}--\ref{lst:repository.cs} показаны соответственно интерфейс репозитория для сущности <<Заказ>> и реализация одного из его методов.

\includelisting
{irepository.cs}{Интерфейс репозитория для сущности <<Заказ>>}

\includelisting
{repository.cs}{Реализация одного из методов интерфейса репозитория для сущности <<Заказ>>}

\section{Тестирование разработанного функционала}

Для тестирования программного обеспечения на разных этапах разработки использовались различные методы тестирования: mock-тесты для проверки корректности реализации бизнес-логики приложения, интеграционные тесты для проверки корректности работы приложения с базой данных и тесты по сценариям использования для проверки корректности работы реализованного веб-приложения. 

В листинге~\ref{lst:mock_test.cs} показана реализация одного из mock-тестов для сущности <<Пользователь>>. 
Данный тест проверяет корректность работы метода регистрации нового пользователя.

\includelisting
{mock_test.cs}{Mock-тест для сущности <<Пользователь>>}

\pagebreak
В листинге~\ref{lst:integration_test.cs} показана реализация одного из интеграционных тестов для сущности <<Пользователь>>.

\includelisting
{integration_test.cs}{Интеграционный тест для сущности <<Пользователь>>}

\section*{Вывод из технологической части}

В ходе выполнения технологической части курсовой работы были выбраны средства реализации программного обеспечения; написан исходный код сущностей, ограничений целостности, проектируемой функции, ролевой модели базы данных; реализован интерфейс доступа к базе данных и протестирован разработанный функционал.

\chapter{Исследовательская часть}

\section{Технические характеристики устройства}

Технические характеристики устройства, на котором было проведено измерение времени выполнения запросов:

\begin{enumerate}
\item[1)]
операционная система Windows 10 Pro x64;
\item[2)]
оперативная память 16 ГБ;
\item[3)]
процессор Intel\textregistered ~Core\texttrademark ~i7-4790K @ 4.00 ГГц.
\end{enumerate}

Измерение времени выполнения запросов проводилось на стороне сервера с помощью класса Stopwatch, который предоставляет набор методов и свойств, которые можно использовать для точного измерения затраченного времени~\cite{Stopwatch}.

\section{Исследование характеристик разработанного программного обеспечения}

Индекс --- это объект базы данных, обеспечивающий дополнительные способы быстрого
поиска и извлечения данных. 
Индекс может создаваться на одном (простой индекс) или нескольких (составной индекс) атрибутах. 
Если в таблице нет индекса, то поиск нужных строк выполняется простым сканированием по всей таблице. 
При наличии индекса время поиска нужных строк можно существенно уменьшить~\cite{Gavrilova2022}. 

Индексирование не влияет на размещение данных какой-либо таблицы в базе данных. 
Ускорение поиска данных через индекс обеспечивается за счет упорядочивания значений индексируемого атрибута (что позволяет просматривать в среднем половину индекса при линейном поиске) и за счет того, что индекс занимает меньше страниц памяти, чем сама таблица, поэтому система тратит меньше времени на чтение индекса, чем на чтение таблицы~\cite{Karpova2009}.

В Microsoft SQL Server индексы хранятся в виде сбалансированных деревьев. 
Представление индекса в виде сбалансированного дерева означает, что стоимость поиска любой строки остается относительно постоянной, независимо от того, где находится эта строка~\cite{Gavrilova2022}.

Таблица или представление может иметь индексы кластеризованные и некластеризованные. 
Кластеризованные индексы сортируют и хранят строки данных в таблицах или представлениях на основе их ключевых значений. 
Этими значениями являются столбцы, включенные в определение индекса. 
Существует только один кластеризованный индекс для каждой таблицы, так как строки данных могут храниться в единственном порядке. 
Строки данных в таблице хранятся в порядке сортировки только в том случае, если таблица содержит кластеризованный индекс. 
Некластеризованные индексы имеют структуру, отдельную от строк данных. 
В некластеризованном индексе содержатся значения ключа некластеризованного индекса, и каждая запись значения ключа содержит указатель на строку данных, содержащую значение ключа. 
В Microsoft SQL Server индексы создаются автоматически при определении ограничений PRIMARY KEY или UNIQUE на основе столбцов таблицы~\cite{Indices}.

Во всех таблицах базы данных, которую использует реализованное в ходе выполнения курсовой работы приложение, есть ограничение PRIMARY KEY, соответственно, Microsoft SQL Server автоматически создает кластеризованные индексы. 
В таблице <<Пользователи>> есть уникальный атрибут <<почта>>, для которого СУБД создает некластеризованный индекс. 
Имеет смысл вручную создать некластеризованный составной индекс по атрибутам <<пункт вылета>>, <<пункт прибытия>> и <<дата вылета>> для таблицы <<Рейсы>> для увеличения скорости поиска рейсов. 

Кроме того, можно вручную создать кластеризованный и некластеризованный индекс по атрибуту <<ID пользователя>> в таблице <<Заказы>> и измерить время выполнения запроса поиска заказа по идентификатору пользователя без индекса, с кластеризованным и некластеризованным индексом.

\section{Время выполнения запроса}

В листинге~\ref{lst:index.sql} приведены команды создания кластеризованного и некластеризованного индекса для таблицы <<Заказы>>.

\includelisting
{index.sql}{Создание кластеризованного и некластеризованного индекса}

В таблицах~\ref{tabular:query1}--\ref{tabular:query2} приведено время выполнения в миллисекундах запроса без индекса, с кластеризованным и некластеризованным индексом при поиске первой и последней записи в таблице соответственно.

\begin{table}[H]
\caption{Время выполнения запроса при поиске первой записи в таблице}
\label{tabular:query1}
\begin{tabular}{|>{\raggedleft}p{2cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Кол-во строк} & \textbf{Время выполнения запроса без индекса, мс} & \textbf{Время выполнения запроса с кластеризованным индексом, мс} & \textbf{Время выполнения запроса с некластеризованным индексом, мс}
\tabularnewline
\hline
100 & 468 & 440 & 450
\tabularnewline
\hline
1000 & 471 & 421 & 439
\tabularnewline
\hline
10000 & 510 & 425 & 445
\tabularnewline
\hline
50000 & 757 & 414 & 453
\tabularnewline
\hline
100000 & 1642 & 472 & 460
\tabularnewline
\hline
250000 & 10701 & 498 & 510
\tabularnewline
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\caption{Время выполнения запроса при поиске последней записи в таблице}
\label{tabular:query2}
\begin{tabular}{|>{\raggedleft}p{2cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|>{\raggedleft}p{4cm}|}
\hline
\textbf{Кол-во строк} & \textbf{Время выполнения запроса без индекса, мс} & \textbf{Время выполнения запроса с кластеризованным индексом, мс} & \textbf{Время выполнения запроса с некластеризованным индексом, мс}
\tabularnewline
\hline
100 & 495 & 442 & 461
\tabularnewline
\hline
1000 & 644 & 448 & 452
\tabularnewline
\hline
10000 & 715 & 457 & 470
\tabularnewline
\hline
50000 & 2136 & 440 & 445
\tabularnewline
\hline
100000 & 5978 & 498 & 510
\tabularnewline
\hline
250000 & 50571 & 524 & 520
\tabularnewline
\hline
\end{tabular}
\end{table}

На рисунках~\ref{img:graph-01}--\ref{img:graph-02} показана зависимость времени выполнения запроса в миллисекундах от количества строк в таблице.

\includeimage
    {graph-01}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость времени выполнения запроса от количества строк в таблице при поиске первой записи}
    
\includeimage
    {graph-02}
    {f}
    {H}
    {0.7\textwidth}
    {Зависимость времени выполнения запроса от количества строк в таблице при поиске последней записи}

\section*{Вывод из исследовательской части}

В ходе выполнения исследовательской части курсовой работы был проведен краткий обзор кластеризованных и некластеризованных индексов; определены таблицы и атрибуты, для которых имеет смысл создавать индексы, и проведен эксперимент по измерению времени выполнения запроса без индекса, с кластеризованным и некластеризованным индексом. 
Согласно полученным при проведении эксперимента данным, при количестве строк в таблице до 10 тысяч существенной разницы во времени выполнения запроса не наблюдается. 
При большем количестве записей время выполнения запроса без использования индекса растет в разы быстрее, а время выполнения запроса с использованием двух типов индексов остается практически неизменным. 
Разница во времени выполнения запроса с кластеризованным и некластеризованным индексом практически отсутствует. 
При 250 тысячах строк в таблице использование индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней.

{\centering \chapter*{ЗАКЛЮЧЕНИЕ}}
\addcontentsline{toc}{chapter}{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы была разработана база данных для хранения и обработки данных авиакомпании, а также веб-приложение, которое ее использует.

Были выполнены следующие задачи:

\begin{enumerate}
\item[1)] проведен обзор существующих веб-приложений для покупки авиабилетов и сформулированы требования и ограничения к разрабатываемой базе данных и приложению;
\item[2)] спроектирована архитектура базы данных, ограничения целостности и ролевая модель на уровне базы данных;
\item[3)] выбраны средства реализации и реализованы спроектированная база данных и необходимый интерфейс для взаимодействия с ней;
\item[4)] исследованы характеристики разработанного программного обеспечения.
\end{enumerate}

В ходе проведения эксперимента при выполнении исследовательской части курсовой работы было установлено, что при 250 тысячах строк в таблице использование и кластеризованного, и некластеризованного индекса увеличивает скорость выполнения запроса в 21 раз при поиске первой записи и в 97 раз при поиске последней.

{\centering \printbibliography[title=СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ,heading=bibintoc]}

{\centering \chapter*{ПРИЛОЖЕНИЕ А}}
\addcontentsline{toc}{chapter}{ПРИЛОЖЕНИЕ А Презентация}
\center{\textbf{Презентация}}

\end{document}
